---
description: Terminates the pipeline successfully, ignoring any previous errors
sidebar_custom_props:
  customCategory: Flow Control
  customIcon: âœ…
---

# Recover

<span className="theme-doc-version-badge badge badge--primary">Control Flow</span><span className="theme-doc-version-badge badge badge--secondary">Pipeline</span>

## Synopsis

Terminates the pipeline successfully, ignoring any previous errors.

## Schema

```yaml
- recover:
    description: <text>
    if: <script>
    ignore_failure: <boolean>
    ignore_missing: <boolean>
    on_failure: <processor[]>
    on_success: <processor[]>
    tag: <string>
```

## Configuration

The following fields are used to define the processor:

|Field|Required|Default|Description|
|---|---|---|---|
|`description`|N|-|Explanatory note|
|`if`|N|-|Condition to run|
|`ignore_failure`|N|`false`|Continue processing if operation fails|
|`ignore_missing`|N|`false`|Skip processing if referenced field doesn't exist|
|`on_failure`|N|-|See <Topic id="handling-failures">Handling Failures</Topic>|
|`on_success`|N|-|See <Topic id="handling-success">Handling Success</Topic>|
|`tag`|N|-|Identifier|

## Details

Terminates the pipeline successfully and returns nil, effectively ignoring any errors that occurred in previous processors. This processor is used for error recovery scenarios where you want to gracefully handle failures without propagating them.

The recover processor acts as an error boundary, catching any previous failures and treating them as successful completions. This allows pipelines to continue processing subsequent log entries without being halted by errors in earlier processors.

:::note
The recover processor doesn't modify any data or fields. It serves purely as an error recovery mechanism to prevent pipeline termination due to previous failures.
:::

This processor is most commonly used in error handling chains, at the end of optional processing sequences, or when you want to ensure that certain errors don't prevent the pipeline from completing.

:::warning
Using recover will suppress all previous errors in the pipeline execution. Make sure this is the intended behavior before using this processor, as it can mask legitimate issues that should be addressed.
:::

## Examples

### Basic Error Recovery

<ExampleGrid>
  <CommentCol>
    Recovering from pipeline errors...
  </CommentCol>
  <CodeCol>
    ```yaml
    - set:
        field: user_id
        value: "{{invalid.field}}"
        on_failure:
          - set:
              field: user_id
              value: "unknown"
          - recover:
              description: "Continue despite field extraction failure"
    ```
  </CodeCol>
  <CommentCol>
    prevents pipeline failure:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "user_id": "unknown"
    }
    ```
  </CodeCol>
</ExampleGrid>

### Conditional Recovery

<ExampleGrid>
  <CommentCol>
    Recovering only under specific conditions...
  </CommentCol>
  <CodeCol>
    ```yaml
    - enrich:
        field: ip_address
        target: geo_data
        on_failure:
          - recover:
              if: "logEntry.source == 'internal'"
              description: "Skip geo-enrichment for internal IPs"
    ```
  </CodeCol>
  <CommentCol>
    recovers based on condition:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "ip_address": "10.0.0.1",
      "source": "internal"
    }
    ```
  </CodeCol>
</ExampleGrid>

### Optional Processing Chain

<ExampleGrid>
  <CommentCol>
    Making an entire processing chain optional...
  </CommentCol>
  <CodeCol>
    ```yaml
    - if:
        condition: "logEntry.type == 'experimental'"
        processors:
          - experimental_processor:
              field: data
          - recover:
              description: "Experimental processing is optional"
              tag: "optional_processing"
    - set:
        field: processed
        value: true
    ```
  </CodeCol>
  <CommentCol>
    continues regardless of experimental processor outcome:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "type": "experimental",
      "processed": true
    }
    ```
  </CodeCol>
</ExampleGrid>

### Multiple Error Handlers

<ExampleGrid>
  <CommentCol>
    Using recover after multiple fallback attempts...
  </CommentCol>
  <CodeCol>
    ```yaml
    - grok:
        pattern: "%{COMMONAPACHELOG}"
        field: message
        on_failure:
          - grok:
              pattern: "%{COMBINEDAPACHELOG}"
              field: message
              on_failure:
                - set:
                    field: parse_status
                    value: "failed"
                - recover:
                    description: "Continue with unparsed log"
    ```
  </CodeCol>
  <CommentCol>
    recovers after all parsing attempts fail:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "message": "unparseable log format",
      "parse_status": "failed"
    }
    ```
  </CodeCol>
</ExampleGrid>

### External Service Fallback

<ExampleGrid>
  <CommentCol>
    Recovering from external service failures...
  </CommentCol>
  <CodeCol>
    ```yaml
    - virustotal:
        field: file_hash
        target: threat_info
        api_key: "{{secrets.vt_key}}"
        on_failure:
          - set:
              field: threat_check_status
              value: "service_unavailable"
          - recover:
              description: "Continue without threat intelligence"
              tag: "external_service_recovery"
    ```
  </CodeCol>
  <CommentCol>
    continues when external API is unavailable:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "file_hash": "abc123...",
      "threat_check_status": "service_unavailable"
    }
    ```
  </CodeCol>
</ExampleGrid>
