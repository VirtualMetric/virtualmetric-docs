---
description: Concatenates values from multiple fields into a single string
sidebar_custom_props: 
  customIcon: ðŸ”—
  customCategory: Parse
---

# Concat

<span className="theme-doc-version-badge badge badge--primary">Parse</span><span className="theme-doc-version-badge badge badge--secondary">Elastic Compatible</span>

## Synopsis

Concatenates values from multiple source fields into a single target field using a specified separator.

## Schema

```yaml {3}
- concat:
  description: <text>
  sources: <string[]>
  target: <ident>
  separator: <string>
  if: <script>
  ignore_failure: <boolean>
  ignore_missing: <boolean>
  on_failure: <processor[]>
  on_success: <processor[]>
  tag: <string>
```

## Configuration

The following fields are used to define the processor:

|Field|Required|Default|Description|
|---|---|---|---|
|`sources`|Y||Array of field names to concatenate|
|`target`|Y||Field to store the concatenated result|
|`separator`|N|`" "` (space)|String used to join the source values|
|`description`|N|-|Explanatory notes|
|`if`|N|-|Condition to run|
|`ignore_failure`|N|`false`|See [Handling Failures](../handling-failures.mdx)|
|`ignore_missing`|N|`false`|Skip missing fields instead of failing|
|`on_failure`|N|-|See [Handling Failures](../handling-failures.mdx)|
|`on_success`|N|-|See [Handling Success](../handling-success.mdx)|
|`tag`|N|-|Identifier|

## Details

The processor reads values from the specified source fields, converts them to strings, and joins them using the separator. Empty values are excluded from the concatenation. If `ignore_missing` is true, missing fields are skipped; otherwise, the processor fails if any source field is missing.

All source values are converted to strings using Go's standard string conversion, making the processor compatible with various data types including numbers, booleans, and complex objects.

:::note
The order of values in the concatenated result follows the order specified in the `sources` array. Rearranging the source fields will change the output order.
:::

:::tip
When concatenating sensitive data or creating identifiers, consider the implications of the separator choice. Some separators may cause issues in downstream systems or create ambiguous results if the source data contains the separator character.
:::

:::caution
Complex objects (maps, arrays) are converted to their string representation, which may not be human-readable. Consider using specific field paths or preprocessing the data before concatenation.
:::

## Examples

### Basic Usage

<ExampleGrid>
  <CommentCol>
    Concatenate first and last name...
  </CommentCol>
  <CodeCol>
    ```json
    {
      "first_name": "John",
      "last_name": "Doe"
    }
    ```
    ```yaml
    processors:
      - concat:
        sources: [first_name, last_name]
        target: full_name
    ```
  </CodeCol>
  <CommentCol>
    into a single field:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "first_name": "John",
      "last_name": "Doe",
      "full_name": "John Doe"
    }
    ```
  </CodeCol>
</ExampleGrid>

### Custom Separator

<ExampleGrid>
  <CommentCol>
    Use a custom separator...
  </CommentCol>
  <CodeCol>
    ```json
    {
      "city": "New York",
      "state": "NY",
      "zip": "10001"
    }
    ```
    ```yaml
    processors:
      - concat:
        sources: [city, state, zip]
        target: address
        separator: ", "
    ```
  </CodeCol>
  <CommentCol>
    to format the output:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "city": "New York",
      "state": "NY", 
      "zip": "10001",
      "address": "New York, NY, 10001"
    }
    ```
  </CodeCol>
</ExampleGrid>

### Multiple Field Types

<ExampleGrid>
  <CommentCol>
    Concatenate different data types...
  </CommentCol>
  <CodeCol>
    ```json
    {
      "user_id": 12345,
      "department": "Engineering",
      "active": true
    }
    ```
    ```yaml
    processors:
      - concat:
        sources: [user_id, department, active]
        target: user_info
        separator: "|"
    ```
  </CodeCol>
  <CommentCol>
    which are automatically converted to strings:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "user_id": 12345,
      "department": "Engineering",
      "active": true,
      "user_info": "12345|Engineering|true"
    }
    ```
  </CodeCol>
</ExampleGrid>

### Handling Missing Fields

<ExampleGrid>
  <CommentCol>
    With `ignore_missing: true`...
  </CommentCol>
  <CodeCol>
    ```json
    {
      "first_name": "Jane",
      "title": "Dr."
    }
    ```
    ```yaml
    processors:
      - concat:
        sources: [title, first_name, middle_name, last_name]
        target: display_name
        separator: " "
        ignore_missing: true
    ```
  </CodeCol>
  <CommentCol>
    missing fields are skipped:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "first_name": "Jane",
      "title": "Dr.",
      "display_name": "Dr. Jane"
    }
    ```
  </CodeCol>
</ExampleGrid>

### Creating URLs

<ExampleGrid>
  <CommentCol>
    Build URLs from components...
  </CommentCol>
  <CodeCol>
    ```json
    {
      "protocol": "https",
      "domain": "api.example.com",
      "path": "/v1/users"
    }
    ```
    ```yaml
    processors:
      - concat:
        sources: [protocol, domain, path]
        target: api_url
        separator: "://"
    ```
  </CodeCol>
  <CommentCol>
    Note: This creates an invalid URL format
  </CommentCol>
  <CodeCol>
    ```json
    {
      "protocol": "https",
      "domain": "api.example.com", 
      "path": "/v1/users",
      "api_url": "https://api.example.com:///v1/users"
    }
    ```
  </CodeCol>
</ExampleGrid>

### Better URL Building

<ExampleGrid>
  <CommentCol>
    For proper URL building, concatenate in parts...
  </CommentCol>
  <CodeCol>
    ```json
    {
      "base_url": "https://api.example.com",
      "endpoint": "/v1/users",
      "query": "limit=10"
    }
    ```
    ```yaml
    processors:
      - concat:
        sources: [base_url, endpoint]
        target: full_url
        separator: ""
      - concat:
        sources: [full_url, query]
        target: api_request
        separator: "?"
    ```
  </CodeCol>
  <CommentCol>
    to create well-formed URLs:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "base_url": "https://api.example.com",
      "endpoint": "/v1/users",
      "query": "limit=10",
      "full_url": "https://api.example.com/v1/users",
      "api_request": "https://api.example.com/v1/users?limit=10"
    }
    ```
  </CodeCol>
</ExampleGrid>

### Log Message Formatting

<ExampleGrid>
  <CommentCol>
    Create structured log messages...
  </CommentCol>
  <CodeCol>
    ```json
    {
      "timestamp": "2024-01-15T10:30:00Z",
      "level": "ERROR",
      "service": "auth-service",
      "message": "Login failed"
    }
    ```
    ```yaml
    processors:
      - concat:
        sources: [timestamp, level, service, message]
        target: formatted_log
        separator: " | "
    ```
  </CodeCol>
  <CommentCol>
    with consistent formatting:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "timestamp": "2024-01-15T10:30:00Z",
      "level": "ERROR",
      "service": "auth-service", 
      "message": "Login failed",
      "formatted_log": "2024-01-15T10:30:00Z | ERROR | auth-service | Login failed"
    }
    ```
  </CodeCol>
</ExampleGrid>

### Empty Separator

<ExampleGrid>
  <CommentCol>
    Use an empty separator...
  </CommentCol>
  <CodeCol>
    ```json
    {
      "prefix": "USER",
      "id": "001",
      "suffix": "ADMIN"
    }
    ```
    ```yaml
    processors:
      - concat:
        sources: [prefix, id, suffix]
        target: user_code
        separator: ""
    ```
  </CodeCol>
  <CommentCol>
    to join values without any delimiter:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "prefix": "USER",
      "id": "001", 
      "suffix": "ADMIN",
      "user_code": "USER001ADMIN"
    }
    ```
  </CodeCol>
</ExampleGrid>