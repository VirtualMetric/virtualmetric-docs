---
sidebar_label: RabbitMQ Threat Intelligence
---

import ImportantConfigFiles from '../reusable/examples/important-config-files.mdx';

# RabbitMQ Integration with Real-Time Threat Intelligence

## Synopsis

This tutorial demonstrates building a real-time threat intelligence pipeline using RabbitMQ as a message broker. You'll learn to consume security events from RabbitMQ queues, enrich them with multiple threat intelligence sources, implement intelligent caching strategies, and distribute alerts through multiple channels for rapid incident response.

**Prerequisites:**

- Access to RabbitMQ broker with appropriate permissions
- API keys for threat intelligence services (VirusTotal, AlienVault, IP Quality Score)
- Understanding of message queuing concepts and threat intelligence workflows

**Configuration files used:**

- `rabbitmq-threat-intel.yml` - Main configuration
- `threat-intel-routing.yml` - Advanced routing rules

**Sample data:**

- Security event messages in JSON format
- IOC (Indicators of Compromise) feeds
- Sample threat intelligence responses

## Scenario

Security teams need to process high-velocity security events and enrich them with real-time threat intelligence for immediate threat detection and response. This tutorial implements a comprehensive threat intelligence pipeline that:

- **Consumes from RabbitMQ** - Processes security events from multiple message queues
- **Multi-source threat intel** - Integrates VirusTotal, AlienVault OTX, and IP Quality Score
- **Intelligent caching** - Implements TTL-based caching to reduce API calls and costs
- **Risk scoring** - Calculates composite threat scores from multiple intelligence sources
- **Alert routing** - Distributes alerts based on severity through different channels
- **Rate limiting** - Manages API quotas and prevents service overload

**Data flow:**

RabbitMQ Events → Threat Intelligence Enrichment → Risk Scoring → Alert Classification → Multi-Channel Distribution

**Techniques demonstrated:**

- RabbitMQ consumer configuration with acknowledgments
- Multi-source threat intelligence integration
- Intelligent caching and rate limiting
- Composite risk scoring algorithms
- Conditional routing for alert distribution

## Setup

### Key Configuration Components

- **Device**: RabbitMQ consumer with queue management
- **Pipeline**: Multi-stage threat intelligence enrichment with caching
- **Targets**: Multiple alert channels (high-priority, standard, archive)

### Quick Reference of Processors Used

|Processor|Purpose|Key Parameters|
|---|---|---|
|`virustotal`|Malware/URL analysis|`field`, `api_key`, `cache_ttl`|
|`alienvault`|Open threat exchange|`field`, `api_key`, `reputation_threshold`|
|`ipqs`|IP quality scoring|`field`, `api_key`, `risk_threshold`|
|`script`|Risk score calculation|`lang`, `source`|
|`iff`|Conditional routing|`if`, `then`, `else`|

### Expected Input/Output Formats

**Input**: JSON security events from RabbitMQ queues
**Output**: Enriched threat intelligence reports with risk scoring and routing metadata

## Trial

<ImportantConfigFiles />

Create a configuration file named `rabbitmq-threat-intel.yml` in your working directory.

### Step 1: Configure RabbitMQ Consumer Device

```yml title="rabbitmq-threat-intel.yml"
devices:
  - id: 1
    name: security_events_consumer
    type: rabbitmq
    status: true
    properties:
      # Connection settings
      host: rabbitmq.security.example.com
      port: 5672
      username: threat-intel-consumer
      password: secure-password
      vhost: /security
      
      # Queue configuration
      queue: security.events.high_priority
      exchange: security.events
      routing_key: "events.ioc.*"
      durable: true
      auto_delete: false
      
      # Consumer settings
      prefetch_count: 10
      auto_ack: false
      exclusive: false
      no_wait: false
      
      # Connection reliability
      heartbeat: 60
      connection_timeout: 30
      channel_max: 20
      frame_max: 131072
      
      # TLS configuration
      ssl: true
      ssl_cert: /etc/ssl/certs/client.pem
      ssl_key: /etc/ssl/private/client.key
      ssl_ca: /etc/ssl/certs/ca.pem
      ssl_verify: true
      
      # Dead letter queue for failed processing
      dlx_exchange: security.events.dlx
      dlx_routing_key: failed.processing
      
      # Consumer performance
      workers: 4
      batch_size: 25
      batch_timeout: 5s
```

### Step 2: Configure Multi-Channel Alert Targets

```yml title="rabbitmq-threat-intel.yml"
targets:
  # High-priority alerts for immediate response
  - name: critical_alerts
    type: rabbitmq
    status: true
    properties:
      host: rabbitmq.security.example.com
      port: 5672
      username: alert-publisher
      password: secure-password
      vhost: /alerts
      exchange: security.alerts
      routing_key: "alerts.critical"
      mandatory: true
      immediate: false
      
  # Standard threat intelligence reports
  - name: threat_intel_reports
    type: file
    status: true
    properties:
      location: /data/threat-intel
      name: "threat_reports_{{date}}.json"
      format: json
      compression: gzip
      rotation: hourly
      
  # Long-term archive for analysis
  - name: threat_archive
    type: file
    status: true
    properties:
      location: /data/archive
      name: "threat_archive_{{date}}.avro"
      format: avro
      compression: snappy
      rotation: daily
      schema:
        type: record
        name: ThreatIntelligenceEvent
        fields:
          - {name: event_id, type: string}
          - {name: timestamp, type: long}
          - {name: source_ip, type: [null, string]}
          - {name: threat_score, type: int}
          - {name: risk_level, type: string}
```

### Step 3: Configure Threat Intelligence Enrichment Pipeline

```yml title="rabbitmq-threat-intel.yml"
pipelines:
  - name: threat_intelligence_enrichment
    processors:
      # Parse the incoming JSON event
      - json:
          field: message
          add_to_root: true
          add_to_root_conflict_strategy: replace
          
      # Validate required fields
      - fail:
          message: "Missing required field: event_id"
          if: "event_id == null"
          
      - fail:
          message: "Missing required field: timestamp"  
          if: "timestamp == null"
      
      # Normalize timestamp
      - date:
          field: timestamp
          target_field: normalized_timestamp
          formats:
            - "2006-01-02T15:04:05.000Z"
            - "2006-01-02T15:04:05Z"
            - "2006-01-02 15:04:05"
          timezone: UTC
      
      # Extract IOCs (Indicators of Compromise)
      - grok:
          field: message_text
          patterns:
            - "(?<ip_addresses>(?:[0-9]{1,3}\\.){3}[0-9]{1,3})"
            - "(?<domains>[a-zA-Z0-9][a-zA-Z0-9\\.-]+\\.[a-zA-Z]{2,})"
            - "(?<file_hashes>[a-fA-F0-9]{32,64})"
            - "(?<urls>https?://[^\\s]+)"
          ignore_failure: true
      
      # Initialize threat intelligence structure
      - set:
          field: threat_intelligence
          value: {}
      
      - set:
          field: threat_score
          value: 0
      
      # VirusTotal enrichment for IPs
      - virustotal:
          field: source_ip
          target_field: threat_intelligence.virustotal_ip
          api_key: "your_virustotal_api_key"
          resource_type: ip
          cache_ttl: 3600
          rate_limit: 4
          timeout: 10
          ignore_failure: true
          if: "source_ip != null and source_ip != ''"
      
      # VirusTotal enrichment for URLs
      - virustotal:
          field: urls
          target_field: threat_intelligence.virustotal_url
          api_key: "your_virustotal_api_key"
          resource_type: url
          cache_ttl: 1800
          ignore_failure: true
          if: "urls != null"      # VirusTotal enrichment for file hashes
      - virustotal:
          field: file_hashes    # keep naming consistent with extraction
          target_field: threat_intelligence.virustotal_hash
          api_key: "your_virustotal_api_key"
          resource_type: file
          cache_ttl: 7200
          ignore_failure: true
          if: "file_hashes != null"      
      # AlienVault OTX enrichment
      - alienvault:
          field: source_ip
          target_field: threat_intelligence.alienvault
          api_key: "your_alienvault_api_key"
          reputation_threshold: 3
          cache_ttl: 3600
          ignore_failure: true
          if: "source_ip != null"
      
      # IP Quality Score enrichment
      - ipqs:
          field: source_ip
          target_field: threat_intelligence.ipqs
          api_key: "your_ipqs_api_key"
          risk_threshold: 75
          cache_ttl: 1800
          strict_mode: false
          ignore_failure: true
          if: "source_ip != null"
      
      # Calculate composite threat score
      - script:
          lang: javascript
          source:|
            var score = 0;
            var factors = [];
            
            // VirusTotal IP analysis
            if (threat_intelligence && threat_intelligence.virustotal_ip) {
              var vt_ip = threat_intelligence.virustotal_ip;
              if (vt_ip.malicious > 0) {
                var malicious_ratio = vt_ip.malicious / (vt_ip.malicious + vt_ip.harmless);
                score += Math.round(malicious_ratio * 30);
                factors.push("VirusTotal IP: " + vt_ip.malicious + " malicious detections");
              }
            }
            
            // VirusTotal URL analysis
            if (threat_intelligence && threat_intelligence.virustotal_url) {
              var vt_url = threat_intelligence.virustotal_url;
              if (vt_url.malicious > 0) {
                score += Math.min(vt_url.malicious * 5, 25);
                factors.push("VirusTotal URL: " + vt_url.malicious + " malicious detections");
              }
            }
            
            // VirusTotal file hash analysis
            if (threat_intelligence && threat_intelligence.virustotal_hash) {
              var vt_hash = threat_intelligence.virustotal_hash;
              if (vt_hash.malicious > 0) {
                score += Math.min(vt_hash.malicious * 3, 35);
                factors.push("VirusTotal Hash: " + vt_hash.malicious + " malicious detections");
              }
            }
            
            // AlienVault reputation
            if (threat_intelligence && threat_intelligence.alienvault) {
              var av = threat_intelligence.alienvault;
              if (av.reputation && av.reputation >= 3) {
                score += av.reputation * 5;
                factors.push("AlienVault reputation: " + av.reputation);
              }
              if (av.pulse_count > 0) {
                score += Math.min(av.pulse_count * 2, 15);
                factors.push("AlienVault pulses: " + av.pulse_count);
              }
            }
            
            // IP Quality Score
            if (threat_intelligence && threat_intelligence.ipqs) {
              var ipqs = threat_intelligence.ipqs;
              if (ipqs.fraud_score > 75) {
                score += Math.round((ipqs.fraud_score - 75) / 5);
                factors.push("IPQS fraud score: " + ipqs.fraud_score);
              }
              if (ipqs.is_vpn||ipqs.is_tor) {
                score += 10;
                factors.push("Anonymous network detected");
              }
              if (ipqs.recent_abuse) {
                score += 15;
                factors.push("Recent abuse detected");
              }
            }
            
            threat_score = Math.min(score, 100);
            threat_factors = factors;
      
      # Determine risk level based on composite score
      - set:
          field: risk_level
          value: "low"
          if: "threat_score < 25"
      
      - set:
          field: risk_level
          value: "medium"
          if: "threat_score >= 25 && threat_score < 50"
      
      - set:
          field: risk_level
          value: "high"
          if: "threat_score >= 50 && threat_score < 75"
      
      - set:
          field: risk_level
          value: "critical"
          if: "threat_score >= 75"
      
      # Add enrichment metadata
      - set:
          field: enrichment_timestamp
          value: "{{_timestamp}}"
      
      - set:
          field: enrichment_sources
          value: ["virustotal", "alienvault", "ipqs"]
      
      # Generate alert if high risk
      - iff:
          if: "risk_level in ['high', 'critical']"
          then:
            - set:
                field: alert_type
                value: "threat_intelligence_alert"
            
            - set:
                field: alert_priority
                value: "critical"
                if: "risk_level == 'critical'"
            
            - set:
                field: alert_priority
                value: "high"
                if: "risk_level == 'high'"
            
            - set:
                field: alert_description
                value: "High-risk IOC detected: {{source_ip}} with threat score {{threat_score}}"
            
            - set:
                field: recommended_actions
                value: ["block_ip", "investigate_source", "check_related_events"]
                if: "risk_level == 'critical'"
            
            - set:
                field: recommended_actions
                value: ["monitor_closely", "investigate_when_possible"]
                if: "risk_level == 'high'"
      
      # Add geographic context if available
      - geoip:
          field: source_ip
          target_field: geographic_context
          database_type: city
          ignore_missing: true
          if: "source_ip != null"
      
      # Clean up temporary fields
      - remove:
          field: message
          ignore_missing: true
      
      - remove:
          field: timestamp
          ignore_missing: true
```

### Step 4: Configure Intelligent Routing

```yml title="rabbitmq-threat-intel.yml"
routes:
  # Critical alerts route
  - name: critical_threat_route
    devices:
      - name: security_events_consumer
    pipelines:
      - name: threat_intelligence_enrichment
    targets:
      - name: critical_alerts
        if: "alert_priority == 'critical'"
      - name: threat_intel_reports
    filters:
      - risk_level: ["critical", "high"]
    
    # Route-level performance tuning
    batch_processing: false  # Real-time for critical alerts
    max_latency: 5s
    
  # Standard processing route
  - name: standard_threat_route
    devices:
      - name: security_events_consumer
    pipelines:
      - name: threat_intelligence_enrichment
    targets:
      - name: threat_intel_reports
      - name: threat_archive
    
    # Batch processing for efficiency
    batch_processing: true
    batch_size: 100
    batch_timeout: 30s
```

### Step 5: Start Threat Intelligence Processing

<Tabs>
  <TabItem value="powershell" label="PowerShell" default>
    ```PowerShell
    .\vmetric-director -console
    ```
  </TabItem>
  <TabItem value="bash" label="Bash">
    ```bash
    ./vmetric-director -console
    ```
  </TabItem>
</Tabs>

### Step 6: Test with Sample Data

Publish a test message to RabbitMQ:

```bash
# Using rabbitmq-admin or your preferred RabbitMQ client
rabbitmq-admin publish --exchange=security.events --routing-key=events.ioc.ip --payload='{"event_id":"evt_001","timestamp":"2025-01-12T10:30:00Z","source_ip":"185.220.101.182","event_type":"suspicious_connection","message_text":"Connection from known malicious IP detected"}'
```

### Step 7: Verify Threat Intelligence Output

Example enriched output:

```json
{
  "event_id": "evt_001",
  "normalized_timestamp": "2025-01-12T10:30:00Z",
  "source_ip": "185.220.101.182",
  "event_type": "suspicious_connection",
  "threat_intelligence": {
    "virustotal_ip": {
      "malicious": 12,
      "harmless": 3,
      "suspicious": 2,
      "undetected": 67
    },
    "alienvault": {
      "reputation": 4,
      "pulse_count": 3,
      "indicators": ["malware_c2", "botnet"]
    },
    "ipqs": {
      "fraud_score": 88,
      "is_vpn": false,
      "is_tor": true,
      "recent_abuse": true,
      "country": "US"
    }
  },
  "threat_score": 78,
  "risk_level": "critical",
  "threat_factors": [
    "VirusTotal IP: 12 malicious detections",
    "AlienVault reputation: 4",
    "AlienVault pulses: 3",
    "IPQS fraud score: 88",
    "Anonymous network detected",
    "Recent abuse detected"
  ],
  "alert_type": "threat_intelligence_alert",
  "alert_priority": "critical",
  "alert_description": "High-risk IOC detected: 185.220.101.182 with threat score 78",
  "recommended_actions": ["block_ip", "investigate_source", "check_related_events"],
  "geographic_context": {
    "country": "US",
    "city": "Unknown",
    "asn": {
      "number": 13335,
      "organization": "Cloudflare, Inc."
    }
  },
  "enrichment_timestamp": "2025-01-12T10:30:15Z",
  "enrichment_sources": ["virustotal", "alienvault", "ipqs"]
}
```

## Monitoring

### Key Metrics to Observe

1. **Message Processing Rate**: Events consumed from RabbitMQ per second
2. **API Performance**: Response times and success rates for threat intel services
3. **Cache Hit Ratio**: Percentage of cached vs fresh API lookups
4. **Alert Generation**: Number of alerts by risk level and response times
5. **Queue Health**: Message queue depth and consumer lag

### Performance Considerations

- **API Rate Limits**: Monitor quotas across all threat intelligence services
- **Caching Strategy**: Optimize TTL values based on data freshness requirements
- **Memory Usage**: Threat intelligence data can be memory intensive
- **Network Latency**: External API calls affect processing speed
- **Dead Letter Queues**: Monitor failed message processing

### Common Troubleshooting

**Issue**: High API costs

- Implement more aggressive caching
- Filter low-value IOCs before enrichment
- Use tiered enrichment based on initial risk assessment

**Issue**: Slow processing

- Increase worker count for parallel processing
- Optimize API timeout values
- Implement asynchronous processing for non-critical enrichment

**Issue**: High false positive rate

- Adjust threat score calculation weights
- Implement reputation whitelisting
- Add temporal analysis for context

**Issue**: RabbitMQ connection errors

- Implement connection retry logic
- Monitor broker health and capacity
- Configure appropriate heartbeat intervals

### Threat Intelligence Analysis

Query threat intelligence data for security analysis:

```bash
# Find critical threats in the last hour
jq 'select(.risk_level == "critical" and (.enrichment_timestamp|fromdateiso8601) > (now - 3600))' threat_reports_2025-01-12.json

# Analyze most common threat factors
jq -r '.threat_factors[]' threat_reports_2025-01-12.json|sort|uniq -c|sort -rn

# Geographic threat distribution
jq -r 'select(.geographic_context != null)|.geographic_context.country' threat_reports_2025-01-12.json|sort|uniq -c|sort -rn
```

### API Quota Management

Monitor API usage patterns:

```console
[2025-01-12 10:30:45] [Information] [virustotal] API quota remaining: 450/500 per day
[2025-01-12 10:30:46] [Information] [alienvault] Cache hit ratio: 73.2%
[2025-01-12 10:30:47] [Warning] [ipqs] Rate limit approaching: 95/100 requests per minute
[2025-01-12 10:30:48] [Information] [threat-intel] Critical alert generated for IP 185.220.101.182
```

:::caution
This tutorial uses real threat intelligence APIs. Ensure you comply with service terms of use and implement appropriate API key security measures in production environments.
:::
