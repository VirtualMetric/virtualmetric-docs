# Encrypt

## Synopsis

```yaml {3-5}
encrypt:
  - algorithm: <string>
  - encryption_key: <string>
  - field: <ident>
  - iv_field: <ident>
  - description: <text>
  - if: <script>
  - ignore_failure: <boolean>
  - ignore_missing: <boolean>
  - on_failure: <processor[]>
  - on_success: <processor[]>
  - tag: <string>
  - with_compression: <boolean>
```

## Description

**Functionality**: Encrypts string values using AES encryption with optional compression. Supports both AES-256-GCM (Galois/Counter Mode) and AES-256-CFB (Cipher Feedback) modes of operation.

## Security Recommendations

### Key Management
- **Key Generation**: Use a cryptographically secure random number generator (CSPRNG) to generate encryption keys
- **Key Rotation**: Implement regular key rotation (e.g., every 90 days)
- **Key Storage**: 
  - Never store encryption keys in plaintext
  - Use a secure key management service (KMS) or hardware security module (HSM)
  - Consider using envelope encryption for key protection
  - Follow the principle of least privilege for key access

### IV (Initialization Vector) Management
- **IV Generation**: Use a CSPRNG to generate IVs
- **IV Uniqueness**: Never reuse IVs with the same key
- **IV Size**: Use appropriate IV sizes:
  - GCM mode: 12 bytes (96 bits) recommended
  - CFB mode: Must equal block size (16 bytes/128 bits for AES)
- **IV Storage**: IVs can be stored with ciphertext as they don't need to be secret

### Secure Storage Guidelines
- **Data at Rest**:
  - Store encrypted data and IVs separately from encryption keys
  - Use authenticated encryption (GCM mode) for data integrity
  - Implement secure backup procedures for encrypted data
  - Consider filesystem encryption for additional protection

- **Data in Transit**:
  - Use TLS for transmitting encrypted data
  - Verify data integrity using message authentication codes (MACs)
  - Implement secure key exchange protocols

### Auditing and Monitoring
- Log all encryption/decryption operations (excluding sensitive data)
- Monitor for unusual patterns that might indicate compromise
- Regularly audit key usage and access patterns
- Maintain detailed records of key rotations

## Parameters

|Field|Required|Default|Description|
|---|---|---|---|
|`algorithm`|N|`AES-256-GCM`|Encryption algorithm to use. Valid values: `AES-256-GCM` or `AES-256-CFB`|
|`encryption_key`|Y|-|32-byte key used for encryption|
|`field`|Y|-|Field containing the value to be encrypted|
|`iv_field`|Y|-|Field where the initialization vector will be stored|
|`description`|N|-|Explanatory note|
|`if`|N|-|Condition to run|
|`ignore_failure`|N|`false`|See [Handling Failures](../handling-failures.mdx)|
|`ignore_missing`|N|`false`|If `true` and `field` doesn't exist, exit quietly|
|`on_failure`|N|-|See [Handling Failures](../handling-failures.mdx)|
|`on_success`|N|-|See [Handling Success](../handling-success.mdx)|
|`tag`|N|-|Identifier|
|`with_compression`|N|`false`|Enable compression before encryption to reduce data size|

## Supported Algorithms

### AES-256-GCM (Default)
- Provides both confidentiality and authenticity
- More secure against tampering
- Slightly slower than CFB mode
- Recommended for most use cases

### AES-256-CFB
- Provides confidentiality
- Faster than GCM mode
- No built-in authentication
- Use when performance is critical and data authenticity is handled separately

## Examples

### AES-256-GCM Encryption

<ExampleGrid>
  <CommentCol>
    Using GCM mode with proper key and IV handling...
  </CommentCol>
  <CodeCol>
    ```json
    {
      "password": "mysecret123"
    }
    ```
    ```yaml
    encrypt:
      - field: password
      - iv_field: password_iv
      - encryption_key: "${ENCRYPTION_KEY}"  # Use environment variable
      - algorithm: AES-256-GCM
    ```
  </CodeCol>
  <CommentCol>
    creates encrypted data and IV:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "password": "KZh/JR2baS2MkZpseKZYoBN2tQ==",
      "password_iv": "F+e8YorshrvFiFTC"
    }
    ```
  </CodeCol>
</ExampleGrid>

### Compression with Encryption

<ExampleGrid>
  <CommentCol>
    Enable compression for large text data...
  </CommentCol>
  <CodeCol>
    ```json
    {
      "log_data": "2024-01-01 DEBUG User logged in from IP 192.168.1.1\n2024-01-01 DEBUG User logged in from IP 192.168.1.1\n..."
    }
    ```
    ```yaml
    encrypt:
      - field: log_data
      - iv_field: log_iv
      - encryption_key: "${ENCRYPTION_KEY}"
      - algorithm: AES-256-GCM
      - with_compression: true
    ```
  </CodeCol>
  <CommentCol>
    produces smaller encrypted output:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "log_data": "Yh8dR2S2kZpsMkYoBN2tQ==",  # Compressed & encrypted
      "log_iv": "K+r8YorvFiFTC"
    }
    ```
  </CodeCol>
</ExampleGrid>

:::warning
- Encryption keys must be exactly 32 bytes for AES-256
- Both the encrypted value and IV are returned as base64 strings
- Never reuse IVs with the same key
- Store encryption keys securely using a key management service
:::

:::note
- The processor caches cipher instances for performance when using the same key
- Compression may not benefit already compressed data (e.g., images)
- Consider using GCM mode unless performance is critical
:::