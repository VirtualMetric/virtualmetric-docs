import Link from '@docusaurus/Link';

# Example: Ingesting Data

This section will help you get started with devices to ingest data with specific protocols, walking you through a common use case.

:::tip
For a detailed discussion, see [this section](../configuration/devices/overview.mdx#configuration).
:::

## Scenarios

We will create a device that will receive data from _Syslog_. We will do this:

- Using a **UDP** connection, which is not secure.
- Using a **TCP** connection, which can be configured for secure access.

## Basic UDP Setup

Use UDP as the listening protocol.

### Step 1. Create Configuration

Create a file named `from-syslog-udp.yml` in our [working directory](./introduction.mdx#working-directory), and then open it with a text editor to enter the following:

```yaml title="from-syslog-udp.yml"
devices:
  - id: 1
    name: from_syslog
    type: syslog
    properties:
      protocol: udp
      address: 0.0.0.0
      port: 514
```

This YAML code specifies that this is a _Syslog_ device, that it will use UDP as its protocol, and that it will be listening on port `514`. You can enter any integer as the `id` value.

However, we also need to define a target that the ingested data willl be directed to, and a route combining the device and the target.

Create a file named `to-console.yml` and add the following target definition to it:

```yaml title="to-console.yml"
targets:
  - name: to_console
    type: console
```

Now create a file named `syslog-to-console.yml` and add the following route definition to it.

```yaml title="syslog-to-console.yml"
routes:
  - name: syslog_to_console
    devices:
      - name: from_syslog
    targets:
      - name: to_console
```

:::tip[info]
To see the ingested data, the stream must be _routed_ to a specific destination, combining the relevant components and orchestrating their flow!

For a detailed discussion, see [Routes: Overview](../configuration/routes.mdx#configuration).
:::

We are now ready to try our configuration.

### Step 2. Run the UDP Device

Open a terminal and enter the following in the command line to start **Director**:

<Tabs>
  <TabItem value="powershell" label="PowerShell" default>
    ```powershell
    vmetric-director
    ```
  </TabItem>
  <TabItem value="bash" label="Bash">
    ```bash
    vmetric-director
    ```
  </TabItem>
</Tabs>

After you press <kb-short>Enter</kb-short>, you will see a stream of initialization messages and our device will be spawned off, waiting to receive _syslog_ messages.

### Step 3. Test Configuration

We can now test the reception using either **Director**'s cross-platform companion **Generator** or the traditional tools available on your platform. Open a new terminal and enter the following in the command line:

<Tabs>
  <TabItem value="powershell" label="PowerShell" default>
    - Using **Generator**

    ```powershell
    vmetric-generator -now -mode=syslog -count=1 -address="127.0.0.1:514" -message="Hello world"
    ```
  </TabItem>
  <TabItem value="bash" label="Bash">
    - Using **Generator**
  
    ```bash
    vmetric-generator -now -mode=syslog -count=1 -address="127.0.0.1:514" -message="Hello world"
    ```
    
    - Using **System Logger**

    ```bash
    logger -n 127.0.0.1 -P 514 "Hello world"
    ```
  </TabItem>
</Tabs>

If you are using **Generator**, after you press <kb-short>Enter</kb-short> the program will start sending our message, one at a time, to _Syslog_. It will signal that it sent the message with a prompt like this:

<Tabs>
  <TabItem value="powershell" label="PowerShell" default>
    ```PowerShell
    1 message sent successfully in 11 ms with 0 error(s) at 2025-06-02 01:54:02.0349011 +0300 +03 m=+2.821324601
    2 messages sent successfully since 2025-06-02 01:54:00 +0300 +03
    ```
  </TabItem>
  <TabItem value="bash" label="Bash">
    ```bash
    1 message sent successfully in 11 ms with 0 error(s) at 2025-06-02 01:54:02.0349011 +0300 +03 m=+2.821324601
    2 messages sent successfully since 2025-06-02 01:54:00 +0300 +03
    ```
  </TabItem>
</Tabs>

If you now switch back to **Director**'s terminal, you will see each sent message (i.e. "Hello world") on the console:

<Tabs>
  <TabItem value="powershell" label="PowerShell" default>
    ```PowerShell
    <1> 2025-06-02T08:33:28+03:00 VirtualMetric Test[3872]: Hello world
    ```
  </TabItem>
  <TabItem value="bash" label="Bash">
    ```bash
    <1> 2025-06-02T08:33:28+03:00 VirtualMetric Test[3872]: Hello world
    ```
  </TabItem>
</Tabs>

If you want to exit both of the processes, press <kb-short>Ctrl+C</kb-short> on either terminal.

## Secure TCP Setup

Now we will create a TLS-enabled device to ingest data over TCP.

### Step 1. Prepare Certificates

First, we have to prepare the TLS certificates. This can be done using either **Director** or **OpenSSL**.

<Tabs>
  <TabItem value="powershell" label="PowerShell" default>
    - Using **Director**

    ```powershell
    vmetric-director -pfx2pem=./cert-file.pfx
    ```
  </TabItem>
  <TabItem value="bash" label="Bash">
    - Using **Director**
    
    ```bash
    vmetric-director -pfx2pem=./cert-file.pfx
    ```
    
    - Using **OpenSSL**
    
    ```bash
    openssl genrsa -out server.key 2048
    openssl req -new -x509 -key server.key -out server.crt -days 365
    ```
  </TabItem>
</Tabs>

The above commands will generate the required `key.pem` and `cert.pem` files.

### Step 2. Place Certificates

Now that we have created the files needed for a secure connection, we must copy them to our root directory:

<Tabs>
  <TabItem value="powershell" label="PowerShell" default>
    ```powershell
    Copy-Item cert.pem key.pem <vm_root>/
    ```
  </TabItem>
  <TabItem value="bash" label="Bash">
    ```bash
    cp cert.pem key.pem <vm_root>/
    ```
  </TabItem>
</Tabs>

:::warning[attention]
- The private key file (`key.pem`) should be readable only by the **Director** process
- The certificate file (`cert.pem`) can be world-readable
:::

### Step 3. Create Secure Configuration

We will now prepare a secure configuration by creating another file named `from-syslog-tcp.yml` in our working directory:

```yaml title="from-syslog-tcp.yml"
devices:
  - id: 2
    name: secure_syslog
    type: syslog
    properties:
      protocol: tcp
      address: 0.0.0.0
      port: 6514
      tls:
        status: true
        cert_name: cert.pem
        key_name: key.pem
```

Note that we specified the certificate files we have created in the previous step. That is because we have set the `status` of the `tls` field to `true`.

We can run our device in the background:

<Tabs>
  <TabItem value="powershell" label="PowerShell" default>
    ```powershell
    vmetric-director -background
    ```
  </TabItem>
  <TabItem value="bash" label="Bash">
    ```bash
    vmetric-director -background
    ```
  </TabItem>
</Tabs>

### Step 4. Test Configuration

Time to test the secure connection. In the terminal where you have previously sent **Generator** messages, and enter the following command:

<Tabs>
  <TabItem value="powershell" label="PowerShell" default>
    ```powershell
    Write-Output "Hello secure world" | openssl s_client -connect 127.0.0.1:6514
    ```
  </TabItem>
  <TabItem value="bash" label="Bash">
    ```bash
    echo "Hello secure world" | openssl s_client -connect 127.0.0.1:6514
    ```
  </TabItem>
</Tabs>

Our test message is sent to the port **Director** is listening via TCP.

Check **Director**'s logs&mdash;the files in the directory indicated [here](./introduction.mdx#logging-setup)&mdash;for success messages on launching and initialization, connection acceptance, and configuration validation.

You can now exit the processes on both terminals by pressing <kb-short>Ctrl+C</kb-short>.

---

In the next section, we will create a different type of target to forward the data ingested through the UDP device we have defined here.

<Link to="./introduction#examples" className="button button--primary" style={{ width: '400px', display: 'inline-block', textAlign: 'center'}}>Back To Introduction</Link>
