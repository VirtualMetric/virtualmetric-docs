import AttentionConfigFiles from './_attention-config-files.mdx';
import AttentionCountForGenerator from './_caution-count-for-generator.mdx';
import InfoUpdateConfigLive from './_info-update-config-live.mdx';
import ComponentEnablement from './_info-component-enablement.mdx'

# Example: Forwarding Data

This section will help you get started with targets to write processed data to specific formats, walking you through common use cases.

:::info
For a detailed discussion of targets, see <Topic id="targets-overview">this section</Topic>.
:::

<AttentionConfigFiles />

## Scenarios

Send data received from _Syslog_ to:

* **Console**: the data will be sent first raw, then normalized to ECS
* **Storage File**: the data will be converted to JSON storage format

## Console Setup and Trial

The most basic target to which we can direct our output is a _console_. In the previous section, to have the _syslog_ data we have ingested&mdash;using the device we have configured there&mdash;directed to the console, we created a route like so:

```yaml
routes:
  - name: syslog_to_console
    devices:
      - name: from_syslog
    targets:
      - name: to_console
```

### Step 1: Configure the target

Assume, however, that we want to customize the stream directed to the console. For that purpose, we will modify our target configuration as:

```yaml title="to-console.yml"
targets:
  - name: to_console
    type: console
    status: true
    properties:
      format: "ecs"
```

<ComponentEnablement />

Put this configuration in the indicated file.

Note that we added a `format` property. With this setting, we will normalize our data to the ECS format which provides a standardized, consistent structure to query Web data.

:::note
Mapping the data fields of disparate log formats to widely known <Topic id="appendix-ecs">ECS</Topic> fields is one of the commonly used <Topic id="normalization">normalization</Topic> techniques.
:::

### Step 2: Run the target

To see the results on the console, go to the terminal you are using for **Director**, and invoke it by entering:

<Tabs>
  <TabItem value="powershell" label="PowerShell" default>
    ```powershell
    .\vmetric-director -background
    ```
  </TabItem>
  <TabItem value="bash" label="Bash">
    ```bash
    ./vmetric-director -background
    ```
  </TabItem>
</Tabs>

This will start **Director** as a background process which you can verify as [indicated before](../single-node-deployment-director.mdx#post-installation). Now enter:

<Tabs>
  <TabItem value="powershell" label="PowerShell" default>
    ```powershell
    .\vmetric-director -console
    ```
  </TabItem>
  <TabItem value="bash" label="Bash">
    ```bash
    ./vmetric-director -console
    ```
  </TabItem>
</Tabs>

The `-console` switch will print status messages to the terminal.

### Step 3: Forward messages to console

Open another terminal to using our message sending tool, and start sending our familiar message:

<Tabs>
  <TabItem value="powershell" label="PowerShell" default>
    - Using generator mode

    ```powershell
    .\vmetric-director -generator -mode syslog -now -count 1 -address "127.0.0.1:514" -message "Hello world"
    ```
  </TabItem>
  <TabItem value="bash" label="Bash">
    - Using generator mode
  
    ```bash
    ./vmetric-director -generator -mode syslog -now -count 1 -address "127.0.0.1:514" -message "Hello world"
    ```
    
    - Using **System Logger**

    ```bash
    logger -n 127.0.0.1 -P 514 "Hello world"
    ```
  </TabItem>
</Tabs>

<AttentionCountForGenerator />

After sending a limited number of messages&mdash;say 5 of them&mdash;press <kb-short>Ctrl+C</kb-short> to exit the process.

If you now switch back to the other terminal, this time you will see that our message is printed to the console in ECS format we have specified:

<Tabs>
  <TabItem value="powershell" label="PowerShell" default>
    ```PowerShell
    {"message":"<3> 2025-06-02T10:38:02+03:00 VirtualMetric Test[7916]: Hello world","@timestamp":"2025-06-02T10:38:02+03:00"}
    ```
  </TabItem>
  <TabItem value="bash" label="Bash">
    ```bash
    {"message":"<3> 2025-06-02T10:38:02+03:00 VirtualMetric Test[7916]: Hello world","@timestamp":"2025-06-02T10:38:02+03:00"}
    ```
  </TabItem>
</Tabs>

## Storage File Setup and Trial

The next type of output we can use is a file. Various formats are available in **DataStream**, but for the sake of simplicity, we will pick the widely used _JSON_ format which is the default for the `file` target type:

```yaml
targets:
  - name: to_json
    type: file
    status: true
    properties:
      location: "<vm_root>/config/Examples"
      name: "from_syslog-{{.Year}}_{{.Month}}_{{.Day}}.json"
```

Create a file named `to-json.yml` in our working directory and save this code in it.

<InfoUpdateConfigLive />

The path we have specified for `location` is where the JSON file will be created. (Do not forget to replace `<vm_root>` with the actual path of your **VirtualMetric** installation.) The nested `name` parameter is for the file: it will have a `from_syslog_` prefix to which the internal field values of `Year`, `Month`, and `Day` will be appended.

:::note
Under `properties`, we did not specify any `format` since JSON is the default for the file target type.
:::

To be able to use this target, we have to configure another route. Create a file named `syslog-to-json.yml` and place this new route definition in it:

```yaml title="syslog-to-json.yml"
routes:
  - name: syslog_to_json
    devices:
      - name: from_syslog
    targets:
      - name: to_json
```

### Step 4: Forward messages to output file

Once again, run `vmetric-director` in `generator` mode (or other equivalent tool) to send messages to _Syslog_:

<Tabs>
  <TabItem value="powershell" label="PowerShell" default>
    - Using generator mode

    ```powershell
    .\vmetric-director -generator -mode syslog -now -count 1 -address "127.0.0.1:514" -message "Hello world"
    ```
  </TabItem>
  <TabItem value="bash" label="Bash">
    - Using generator mode
  
    ```bash
    ./vmetric-director -generator -mode syslog -now -count 1 -address "127.0.0.1:514" -message "Hello world"
    ```
    
    - Using **System Logger**

    ```bash
    logger -n 127.0.0.1 -P 514 "Hello world"
    ```
  </TabItem>
</Tabs>

To have this _Syslog_ message directed to the storage file we have configured, check **Director**'s status messages from your other terminal:

**Director** will issue prompts like the following while it is writing the ingested data to our JSON file:

<Tabs>
  <TabItem value="powershell" label="PowerShell">
    ```PowerShell
    [2025-06-02 11:15:58] [Information] [vmetric-director] Completed processing of to_json target logs. Number of processed logs: 1000
    ```
  </TabItem>
  <TabItem value="bash" label="Bash">
    ```bash
    [2025-06-02 11:15:58] [Information] [vmetric-director] Completed processing of to_json target logs. Number of processed logs: 1000
    ```
  </TabItem>
</Tabs>

Now we can check our output. In our working directory, you will find a file with a name like `from_syslog-2025_06_02.json`. Open it with a text editor. You will find that the ingested data has been stored in it in a format like this:

```json
{"epoch":1748852145,"message":"<3> 2025-06-02T11:15:45+03:00 VirtualMetric Test[5832]: Hello world"}
```

Since we have only sent the same message multiple times, there will be multiple copies of it in the file.

## Monitoring

Check the log file indicated <Topic id="examples-logging-setup">earlier</Topic>. If there were no errors during the trial, it should be blank.

---

In the next section, we will learn how **Director** handles _pipelines_.
