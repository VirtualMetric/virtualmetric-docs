---
description: Terminates the pipeline successfully, ignoring any previous errors
sidebar_custom_props:
  customCategory: Flow Control
  customIcon: ✅
---

# Recover

<span className="theme-doc-version-badge badge badge--primary">Control Flow</span><span className="theme-doc-version-badge badge badge--secondary">Pipeline</span>

## Synopsis

Recovers from errors that occurred in previous processors, allowing the pipeline to continue execution. Acts like a try-catch mechanism in programming languages.

## Schema

```yaml
- recover:
    description: <text>
    if: <script>
    ignore_failure: <boolean>
    on_failure: <processor[]>
    on_success: <processor[]>
    tag: <string>
```

## Configuration

The following fields are used to define the processor:

|Field|Required|Default|Description|
|---|---|---|---|
|`description`|N|-|Explanatory note|
|`if`|N|-|Condition to run|
|`ignore_failure`|N|`false`|Continue processing if operation fails|
|`on_failure`|N|-|See <Topic id="pipelines-handling-failures">Handling Failures</Topic>|
|`on_success`|N|-|See <Topic id="pipelines-handling-success">Handling Success</Topic>|
|`tag`|N|-|Identifier|

## Details

The `recover` processor clears error states from previous processors, allowing the pipeline to continue execution as if no error occurred. It functions similarly to exception handling in programming languages, where errors are caught and handled gracefully.

**Error Recovery Mechanism:**
- Clears any error state from processors in the current `on_failure` chain
- Allows the pipeline to continue with subsequent processors
- Does not modify event data—purely handles error state
- Can be conditional using the `if` field

**Common Use Cases:**
- **Parsing Failures**: Recover when optional parsing fails (e.g., grok patterns, date formats)
- **Enrichment Failures**: Continue when external enrichment services are unavailable
- **Validation Failures**: Proceed with default values when validation fails
- **Optional Processing**: Make certain processing steps non-critical

:::note
The recover processor doesn't modify any data or fields. It serves purely as an error recovery mechanism to prevent pipeline termination due to previous failures.
:::

This processor is most commonly used in error handling chains, at the end of optional processing sequences, or when you want to ensure that certain errors don't prevent the pipeline from completing.

:::warning
Using recover will suppress all previous errors in the pipeline execution. Make sure this is the intended behavior before using this processor, as it can mask legitimate issues that should be addressed.
:::

## Examples

### Basic Error Recovery

<ExampleGrid>
  <CommentCol>
    Recovering from pipeline errors...
  </CommentCol>
  <CodeCol>
    ```yaml
    - set:
        field: user_id
        value: "{{invalid.field}}"
        on_failure:
          - set:
              field: user_id
              value: "unknown"
          - recover:
              description: "Continue despite field extraction failure"
    ```
  </CodeCol>
  <CommentCol>
    prevents pipeline failure:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "user_id": "unknown"
    }
    ```
  </CodeCol>
</ExampleGrid>

### Conditional Recovery

<ExampleGrid>
  <CommentCol>
    Recovering only under specific conditions...
  </CommentCol>
  <CodeCol>
    ```yaml
    - enrich:
        field: ip_address
        target: geo_data
        on_failure:
          - recover:
              if: "logEntry.source == 'internal'"
              description: "Skip geo-enrichment for internal IPs"
    ```
  </CodeCol>
  <CommentCol>
    recovers based on condition:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "ip_address": "10.0.0.1",
      "source": "internal"
    }
    ```
  </CodeCol>
</ExampleGrid>

### Optional Processing Chain

<ExampleGrid>
  <CommentCol>
    Making an entire processing chain optional...
  </CommentCol>
  <CodeCol>
    ```yaml
    - if:
        condition: "logEntry.type == 'experimental'"
        processors:
          - experimental_processor:
              field: data
          - recover:
              description: "Experimental processing is optional"
              tag: "optional_processing"
    - set:
        field: processed
        value: true
    ```
  </CodeCol>
  <CommentCol>
    continues regardless of experimental processor outcome:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "type": "experimental",
      "processed": true
    }
    ```
  </CodeCol>
</ExampleGrid>

### Multiple Error Handlers

<ExampleGrid>
  <CommentCol>
    Using recover after multiple fallback attempts...
  </CommentCol>
  <CodeCol>
    ```yaml
    - grok:
        pattern: "%{COMMONAPACHELOG}"
        field: message
        on_failure:
          - grok:
              pattern: "%{COMBINEDAPACHELOG}"
              field: message
              on_failure:
                - set:
                    field: parse_status
                    value: "failed"
                - recover:
                    description: "Continue with unparsed log"
    ```
  </CodeCol>
  <CommentCol>
    recovers after all parsing attempts fail:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "message": "unparseable log format",
      "parse_status": "failed"
    }
    ```
  </CodeCol>
</ExampleGrid>

### External Service Fallback

<ExampleGrid>
  <CommentCol>
    Recovering from external service failures...
  </CommentCol>
  <CodeCol>
    ```yaml
    - virustotal:
        field: file_hash
        target: threat_info
        api_key: "{{secrets.vt_key}}"
        on_failure:
          - set:
              field: threat_check_status
              value: "service_unavailable"
          - recover:
              description: "Continue without threat intelligence"
              tag: "external_service_recovery"
    ```
  </CodeCol>
  <CommentCol>
    continues when external API is unavailable:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "file_hash": "abc123...",
      "threat_check_status": "service_unavailable"
    }
    ```
  </CodeCol>
</ExampleGrid>
