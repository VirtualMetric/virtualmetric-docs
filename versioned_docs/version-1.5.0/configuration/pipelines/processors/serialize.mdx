---
description: Converts structured data to serialized formats like JSON, XML, CSV, and TSV
sidebar_custom_props: 
  customIcon: ðŸ“¦
  customCategory: Data Manipulation
---

# Serialize

<span className="theme-doc-version-badge badge badge--primary">Data Processing</span><span className="theme-doc-version-badge badge badge--secondary">Data Export</span><span className="theme-doc-version-badge badge badge--secondary">Format Conversion</span>

## Synopsis

A data transformation processor that converts structured data into serialized formats including JSON, XML, CSV, TSV, and custom delimited formats, enabling data export and format standardization across different systems.

## Schema

```yaml {2}
- serialize:
    type: <enum>
    fields: <string[]>
    source_field: <ident>
    target_field: <ident>
    delimiter: <string>
    description: <text>
    if: <script>
    ignore_failure: <boolean>
    ignore_missing: <boolean>
    include_header: <boolean>
    quote_char: <string>
    escape_char: <string>
    root_element: <string>
    xml_namespace: <string>
    xml_template: <string>
    xml_attribute: <string>
    omit_xml_declaration: <boolean>
    use_root_as_element: <boolean>
    on_failure: <processor[]>
    on_success: <processor[]>
    tag: <string>
```

## Configuration

The following fields are used to define the processor:

|Field|Required|Default|Description|
|---|---|---|---|
|`type`|Y|-|Serialization format: `json`, `xml`, `csv`, `tsv`, or `delimited`|
|`fields`|N|all fields|Fields to serialize (supports wildcards and exclusions)|
|`source_field`|N|top-level|Source field containing data to serialize|
|`target_field`|N|`_raw`|Field to store the serialized output|
|`delimiter`|N|`,`|Delimiter for custom delimited format|
|`include_header`|N|`false`|Include header row for CSV/TSV/delimited|
|`quote_char`|N|`"`|Quote character for CSV/delimited formats|
|`escape_char`|N|-|Escape character for CSV/delimited formats|
|`root_element`|N|`root`|Root element name for XML output|
|`xml_namespace`|N|-|XML namespace URI|
|`xml_template`|N|-|XML element template name|
|`xml_attribute`|N|-|XML attribute name for templated output|
|`omit_xml_declaration`|N|`false`|Omit XML declaration header|
|`use_root_as_element`|N|`false`|Use single key as root element|
|`description`|N|-|Explanatory note|
|`if`|N|-|Condition to run|
|`ignore_failure`|N|`false`|Continue if serialization fails|
|`ignore_missing`|N|`false`|Continue if source field doesn't exist|
|`on_failure`|N|-|See <Topic id="handling-failures">Handling Failures</Topic>|
|`on_success`|N|-|See <Topic id="handling-success">Handling Success</Topic>|
|`tag`|N|-|Identifier|

## Details

The processor supports multiple serialization formats with format-specific configuration options. Field selection allows precise control over which data elements are included in the serialized output.

:::note
Field selection supports wildcard patterns (*) and exclusions (!fieldname) for flexible data filtering.
:::

JSON serialization provides compact, standards-compliant output suitable for APIs and data interchange. XML serialization offers extensive customization including namespaces, templates, and attribute-based formatting for enterprise integration scenarios.

CSV and TSV formats support header generation and custom delimiters for data analysis and reporting workflows. The delimited format provides maximum flexibility with configurable separators, quotes, and escape characters.

:::warning
Large datasets may impact performance - consider filtering fields to optimize serialization speed.
:::

## Examples

### JSON Serialization

<ExampleGrid>
  <CommentCol>
    Converting structured data to JSON...
  </CommentCol>
  <CodeCol>
    ```json
    {
      "user": {
        "id": 123,
        "name": "John Doe",
        "email": "john@example.com",
        "active": true
      }
    }
    ```
    ```yaml
    - serialize:
        type: json
        source_field: user
        target_field: user_json
    ```
  </CodeCol>
  <CommentCol>
    produces JSON string:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "user": {
        "id": 123,
        "name": "John Doe",
        "email": "john@example.com",
        "active": true
      },
      "user_json": "{\"id\":123,\"name\":\"John Doe\",\"email\":\"john@example.com\",\"active\":true}"
    }
    ```
  </CodeCol>
</ExampleGrid>

### XML Serialization

<ExampleGrid>
  <CommentCol>
    Converting data to XML format...
  </CommentCol>
  <CodeCol>
    ```json
    {
      "config": {
        "database": "production",
        "timeout": 30,
        "enabled": true
      }
    }
    ```
    ```yaml
    - serialize:
        type: xml
        source_field: config
        target_field: config_xml
        root_element: Configuration
    ```
  </CodeCol>
  <CommentCol>
    creates structured XML:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "config": {
        "database": "production",
        "timeout": 30,
        "enabled": true
      },
      "config_xml": "<?xml version=\"1.0\" encoding=\"UTF-8\"?><Configuration><database>production</database><enabled>true</enabled><timeout>30</timeout></Configuration>"
    }
    ```
  </CodeCol>
</ExampleGrid>

### CSV with Header

<ExampleGrid>
  <CommentCol>
    Exporting data as CSV with header...
  </CommentCol>
  <CodeCol>
    ```json
    {
      "record": {
        "id": "001",
        "product": "Widget A",
        "price": 19.99,
        "quantity": 5
      }
    }
    ```
    ```yaml
    - serialize:
        type: csv
        source_field: record
        target_field: csv_output
        include_header: true
    ```
  </CodeCol>
  <CommentCol>
    generates CSV format:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "record": {
        "id": "001",
        "product": "Widget A",
        "price": 19.99,
        "quantity": 5
      },
      "csv_output": "id,price,product,quantity\n001,19.99,Widget A,5"
    }
    ```
  </CodeCol>
</ExampleGrid>

### Field Selection

<ExampleGrid>
  <CommentCol>
    Serializing specific fields only...
  </CommentCol>
  <CodeCol>
    ```json
    {
      "user_data": {
        "id": 456,
        "username": "jane_doe",
        "password": "secret123",
        "email": "jane@example.com",
        "last_login": "2024-01-15T10:30:00Z"
      }
    }
    ```
    ```yaml
    - serialize:
        type: json
        source_field: user_data
        target_field: public_data
        fields: ["id", "username", "email"]
    ```
  </CodeCol>
  <CommentCol>
    excludes sensitive information:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "user_data": {
        "id": 456,
        "username": "jane_doe",
        "password": "secret123",
        "email": "jane@example.com",
        "last_login": "2024-01-15T10:30:00Z"
      },
      "public_data": "{\"email\":\"jane@example.com\",\"id\":456,\"username\":\"jane_doe\"}"
    }
    ```
  </CodeCol>
</ExampleGrid>

### XML with Attributes

<ExampleGrid>
  <CommentCol>
    Creating XML with attribute-based format...
  </CommentCol>
  <CodeCol>
    ```json
    {
      "event_data": {
        "EventID": "4624",
        "Level": "Information",
        "Source": "Security",
        "Computer": "SERVER01"
      }
    }
    ```
    ```yaml
    - serialize:
        type: xml
        source_field: event_data
        target_field: event_xml
        root_element: Event
        xml_template: Data
        xml_attribute: Name
    ```
  </CodeCol>
  <CommentCol>
    produces Windows Event-style XML:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "event_data": {
        "EventID": "4624",
        "Level": "Information",
        "Source": "Security",
        "Computer": "SERVER01"
      },
      "event_xml": "<?xml version=\"1.0\" encoding=\"UTF-8\"?><Event><Data Name=\"Computer\">SERVER01</Data><Data Name=\"EventID\">4624</Data><Data Name=\"Level\">Information</Data><Data Name=\"Source\">Security</Data></Event>"
    }
    ```
  </CodeCol>
</ExampleGrid>

### Custom Delimited Format

<ExampleGrid>
  <CommentCol>
    Creating pipe-delimited output...
  </CommentCol>
  <CodeCol>
    ```json
    {
      "metrics": {
        "cpu_usage": 75.2,
        "memory_usage": 68.5,
        "disk_usage": 45.3,
        "network_io": 1024
      }
    }
    ```
    ```yaml
    - serialize:
        type: delimited
        source_field: metrics
        target_field: metrics_pipe
        delimiter: "|"
        include_header: true
    ```
  </CodeCol>
  <CommentCol>
    creates pipe-separated values:
  </CommentCol>
  <CodeCol>
    ```json
    {
      "metrics": {
        "cpu_usage": 75.2,
        "memory_usage": 68.5,
        "disk_usage": 45.3,
        "network_io": 1024
      },
      "metrics_pipe": "cpu_usage|disk_usage|memory_usage|network_io\n75.2|45.3|68.5|1024"
    }
    ```
  </CodeCol>
</ExampleGrid>
